[
  {
    "name": "SIGHUP",
    "number": 1,
    "mipsNumber": 1,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Hangup detected on controlling terminal or death of controlling process",
    "usage": "Sent when a terminal is closed or a session leader exits. Commonly used to tell daemons to reload their configuration files (e.g. nginx, Apache). The name comes from 'hang up' on serial lines.",
    "category": "terminal"
  },
  {
    "name": "SIGINT",
    "number": 2,
    "mipsNumber": 2,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Interrupt from keyboard (Ctrl+C)",
    "usage": "Sent when the user types the interrupt character (usually Ctrl+C). The default action is to terminate the process, but it can be caught to perform cleanup. Programs like shells and editors catch this to cancel the current operation rather than exit.",
    "category": "terminal"
  },
  {
    "name": "SIGQUIT",
    "number": 3,
    "mipsNumber": 3,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Quit from keyboard (Ctrl+\\)",
    "usage": "Similar to SIGINT but produces a core dump. Sent when the user types the quit character (usually Ctrl+\\). Used when a process is stuck and SIGINT doesn't work—the core dump helps with post-mortem debugging.",
    "category": "terminal"
  },
  {
    "name": "SIGILL",
    "number": 4,
    "mipsNumber": 4,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Illegal instruction",
    "usage": "Sent when the CPU encounters an instruction it cannot execute. Common causes: executing data as code, using instructions not supported by the CPU (e.g. SSE on old hardware), or a corrupted binary. Often indicates a serious bug or ABI mismatch.",
    "category": "error"
  },
  {
    "name": "SIGTRAP",
    "number": 5,
    "mipsNumber": 5,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Trace/breakpoint trap",
    "usage": "Used by debuggers (like GDB) for breakpoints and single-stepping. When a process executes an int3 (x86) or brk (ARM) instruction, the kernel sends SIGTRAP. Also sent after each instruction when ptrace single-step mode is active.",
    "category": "error"
  },
  {
    "name": "SIGABRT",
    "number": 6,
    "mipsNumber": 6,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Abort signal from abort(3)",
    "usage": "Sent by the abort() function, typically called when a program detects an unrecoverable internal error. assert() failures call abort(). C++ also calls abort() for unhandled exceptions or pure virtual function calls. Produces a core dump for debugging.",
    "category": "error"
  },
  {
    "name": "SIGBUS",
    "number": 7,
    "mipsNumber": 10,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Bus error (bad memory access)",
    "usage": "Sent on hardware-level memory access errors: unaligned access (on strict architectures), accessing memory-mapped files that have been truncated, or accessing non-existent physical addresses. On macOS, misaligned SSE operations trigger SIGBUS rather than SIGSEGV.",
    "category": "error"
  },
  {
    "name": "SIGFPE",
    "number": 8,
    "mipsNumber": 8,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Floating-point exception",
    "usage": "Despite the name, this is sent for any arithmetic error including integer division by zero and integer overflow (when trapped). Floating-point operations typically return NaN/Inf by default per IEEE 754—SIGFPE is only sent when FP exception trapping is explicitly enabled.",
    "category": "error"
  },
  {
    "name": "SIGKILL",
    "number": 9,
    "mipsNumber": 9,
    "action": "Term",
    "catchable": false,
    "blockable": false,
    "posix": true,
    "description": "Kill signal (cannot be caught or ignored)",
    "usage": "Unconditionally terminates a process. Cannot be caught, blocked, or ignored—the kernel enforces termination immediately. Use as a last resort when SIGTERM fails. The OOM killer sends SIGKILL to reclaim memory. Note: the process cannot perform cleanup, so data loss is possible.",
    "category": "process"
  },
  {
    "name": "SIGUSR1",
    "number": 10,
    "mipsNumber": 16,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "User-defined signal 1",
    "usage": "Reserved for application-specific use. No predefined meaning—the application decides what it means. Common uses: toggling debug mode, triggering log rotation, dumping internal state. dd uses SIGUSR1 to print transfer statistics.",
    "category": "user"
  },
  {
    "name": "SIGSEGV",
    "number": 11,
    "mipsNumber": 11,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Invalid memory reference (segmentation fault)",
    "usage": "The most common crash signal. Sent when a process accesses memory it doesn't have permission to access: dereferencing NULL, buffer overflows, use-after-free, stack overflow. While catchable, continuing after SIGSEGV leads to undefined behavior. Produces a core dump.",
    "category": "error"
  },
  {
    "name": "SIGUSR2",
    "number": 12,
    "mipsNumber": 17,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "User-defined signal 2",
    "usage": "Second user-defined signal, same as SIGUSR1 but independent. Useful when an application needs two distinct signal-triggered actions. Some applications use SIGUSR2 to trigger graceful shutdown while SIGUSR1 triggers reload.",
    "category": "user"
  },
  {
    "name": "SIGPIPE",
    "number": 13,
    "mipsNumber": 13,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Broken pipe: write to pipe with no readers",
    "usage": "Sent when a process writes to a pipe or socket whose read end has been closed. Classic example: 'cat largefile | head -1' — cat gets SIGPIPE after head exits. Network servers commonly ignore SIGPIPE and handle EPIPE errors from write() instead.",
    "category": "io"
  },
  {
    "name": "SIGALRM",
    "number": 14,
    "mipsNumber": 14,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Timer signal from alarm(2)",
    "usage": "Sent when a timer set by alarm() or setitimer(ITIMER_REAL) expires. Measures real (wall-clock) time. Used to implement timeouts for blocking operations. Modern code often prefers timer_create() with SIGEV_THREAD or timerfd for more precise timing.",
    "category": "timer"
  },
  {
    "name": "SIGTERM",
    "number": 15,
    "mipsNumber": 15,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Termination signal",
    "usage": "The default signal sent by the 'kill' command. Politely asks a process to terminate, giving it a chance to perform cleanup (close files, remove temp files, release resources). Programs should handle SIGTERM for graceful shutdown. systemd sends SIGTERM before SIGKILL.",
    "category": "process"
  },
  {
    "name": "SIGSTKFLT",
    "number": 16,
    "mipsNumber": 7,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Stack fault on coprocessor",
    "usage": "Originally for math coprocessor stack faults (x87 FPU). Virtually unused on modern Linux—the kernel doesn't generate this signal. Historically relevant for i386 systems with separate math coprocessors. Kept for backward compatibility.",
    "category": "error"
  },
  {
    "name": "SIGCHLD",
    "number": 17,
    "mipsNumber": 18,
    "action": "Ign",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Child stopped or terminated",
    "usage": "Sent to a parent process when a child process terminates, is stopped, or resumes. Essential for proper child process management—without handling SIGCHLD or calling wait(), terminated children become zombies. Shells use this to report background job completion.",
    "category": "process"
  },
  {
    "name": "SIGCONT",
    "number": 18,
    "mipsNumber": 25,
    "action": "Cont",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Continue if stopped",
    "usage": "Resumes a process that was stopped by SIGSTOP or SIGTSTP. Even if caught or ignored, the process is always resumed. Used by shells for job control: typing 'fg' sends SIGCONT. The 'kill -CONT' command can resume any process you own.",
    "category": "process"
  },
  {
    "name": "SIGSTOP",
    "number": 19,
    "mipsNumber": 23,
    "action": "Stop",
    "catchable": false,
    "blockable": false,
    "posix": true,
    "description": "Stop process (cannot be caught or ignored)",
    "usage": "Unconditionally stops (suspends) a process. Like SIGKILL, it cannot be caught, blocked, or ignored. The process is frozen until it receives SIGCONT. Used by debuggers and for process control. Different from SIGTSTP which can be caught.",
    "category": "process"
  },
  {
    "name": "SIGTSTP",
    "number": 20,
    "mipsNumber": 24,
    "action": "Stop",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Stop typed at terminal (Ctrl+Z)",
    "usage": "Sent when the user types the suspend character (usually Ctrl+Z). Unlike SIGSTOP, this can be caught—editors and interactive programs catch it to save state before stopping. The shell then typically displays '[1]+ Stopped' and returns the prompt.",
    "category": "terminal"
  },
  {
    "name": "SIGTTIN",
    "number": 21,
    "mipsNumber": 26,
    "action": "Stop",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Terminal input for background process",
    "usage": "Sent to a background process that tries to read from its controlling terminal. Since background processes shouldn't interfere with foreground I/O, the process is stopped until brought to the foreground with 'fg'. Only applies to processes in a terminal session.",
    "category": "terminal"
  },
  {
    "name": "SIGTTOU",
    "number": 22,
    "mipsNumber": 27,
    "action": "Stop",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Terminal output for background process",
    "usage": "Sent to a background process that tries to write to its controlling terminal (when the terminal's TOSTOP flag is set). Similar to SIGTTIN but for output. Most terminals don't set TOSTOP by default, so background processes can usually write freely.",
    "category": "terminal"
  },
  {
    "name": "SIGURG",
    "number": 23,
    "mipsNumber": 21,
    "action": "Ign",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Urgent condition on socket (out-of-band data)",
    "usage": "Sent when out-of-band (OOB) data arrives on a socket. OOB data is a TCP feature that allows sending urgent data outside the normal stream. Rarely used in modern networking—most protocols use in-band signaling instead. select() can also detect OOB data.",
    "category": "io"
  },
  {
    "name": "SIGXCPU",
    "number": 24,
    "mipsNumber": 30,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "CPU time limit exceeded (setrlimit)",
    "usage": "Sent when a process exceeds its soft CPU time limit (set via setrlimit or ulimit). The process can catch this for cleanup. If the process continues, it receives SIGKILL when it hits the hard limit. Used by batch job systems and shared hosting to enforce CPU quotas.",
    "category": "process"
  },
  {
    "name": "SIGXFSZ",
    "number": 25,
    "mipsNumber": 31,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "File size limit exceeded (setrlimit)",
    "usage": "Sent when a process tries to create a file larger than the allowed maximum (set via setrlimit or ulimit). The write that would exceed the limit fails with EFBIG. Rarely encountered today as file size limits are usually set very high or unlimited.",
    "category": "io"
  },
  {
    "name": "SIGVTALRM",
    "number": 26,
    "mipsNumber": 28,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Virtual alarm clock (process CPU time)",
    "usage": "Sent when a timer set by setitimer(ITIMER_VIRTUAL) expires. Only counts time when the process is executing in user space (not kernel time or sleep). Used for profiling CPU-intensive code. Unlike SIGALRM, it doesn't count wall-clock time.",
    "category": "timer"
  },
  {
    "name": "SIGPROF",
    "number": 27,
    "mipsNumber": 29,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Profiling timer expired",
    "usage": "Sent when a timer set by setitimer(ITIMER_PROF) expires. Counts both user and kernel CPU time (unlike SIGVTALRM which only counts user time). Used by profiling tools like gprof. Modern profilers often use perf_events instead.",
    "category": "timer"
  },
  {
    "name": "SIGWINCH",
    "number": 28,
    "mipsNumber": 20,
    "action": "Ign",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Window resize signal",
    "usage": "Sent when the terminal window is resized. Programs like vim, less, top, and tmux catch this to redraw their display at the new size. The new dimensions can be read with ioctl(TIOCGWINSZ). Default action is to ignore.",
    "category": "terminal"
  },
  {
    "name": "SIGIO",
    "number": 29,
    "mipsNumber": 22,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "I/O now possible (async I/O)",
    "usage": "Sent when a file descriptor becomes ready for I/O (using fcntl F_SETSIG/F_SETFL with O_ASYNC). Provides signal-driven I/O as an alternative to poll/epoll/select. Also known as SIGPOLL on System V. Largely superseded by epoll on Linux.",
    "category": "io"
  },
  {
    "name": "SIGPWR",
    "number": 30,
    "mipsNumber": 19,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Power failure",
    "usage": "Sent when a UPS (uninterruptible power supply) signals a power failure. The init process (or systemd) typically receives this and initiates a shutdown. Not widely used on modern systems where UPS management daemons handle power events directly.",
    "category": "process"
  },
  {
    "name": "SIGSYS",
    "number": 31,
    "mipsNumber": 12,
    "action": "Core",
    "catchable": true,
    "blockable": true,
    "posix": false,
    "description": "Bad system call (invalid syscall number)",
    "usage": "Sent when a process attempts an invalid system call. Most commonly triggered by seccomp filters that reject disallowed syscalls (used by Docker, Chrome sandbox, systemd sandboxing). Also sent when running binaries built for a different OS or architecture.",
    "category": "error"
  },
  {
    "name": "SIGRTMIN...SIGRTMAX",
    "number": 34,
    "mipsNumber": 34,
    "action": "Term",
    "catchable": true,
    "blockable": true,
    "posix": true,
    "description": "Real-time signals (typically 34-64)",
    "usage": "A range of signals (usually 34 to 64) for application use. Unlike standard signals, real-time signals are queued (multiple instances don't merge), delivered in order, and can carry an integer or pointer payload via sigqueue(). Used by POSIX timers, AIO, and thread libraries. glibc reserves the first few (SIGRTMIN+0 to +2) for NPTL thread implementation.",
    "category": "realtime"
  }
]
