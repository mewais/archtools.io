[
  {
    "id": "x86-64-sysv",
    "name": "x86-64 System V",
    "arch": "x86-64",
    "os": "Linux, macOS, BSD",
    "intArgRegs": ["rdi", "rsi", "rdx", "rcx", "r8", "r9"],
    "floatArgRegs": ["xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5", "xmm6", "xmm7"],
    "intReturnRegs": ["rax", "rdx"],
    "floatReturnRegs": ["xmm0", "xmm1"],
    "calleeSaved": ["rbx", "rbp", "r12", "r13", "r14", "r15"],
    "callerSaved": ["rax", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "r10", "r11"],
    "stackPointer": "rsp",
    "framePointer": "rbp",
    "linkRegister": null,
    "stackAlignment": 16,
    "redZone": 128,
    "structPassing": "Structs up to 16 bytes are passed in registers (classified by eightbyte). Larger structs are passed via a hidden pointer in the first integer register (rdi). Return structs up to 16 bytes in rax/rdx; larger ones via hidden pointer passed in rdi (caller allocates).",
    "variadicNotes": "The al register must contain the number of vector (SSE) registers used for arguments (0-8). All variadic float arguments are passed in SSE registers, not x87.",
    "notes": "The 128-byte red zone below rsp can be used by leaf functions without adjusting rsp. This optimization avoids the overhead of stack frame setup for small leaf functions. The System V ABI is used by virtually all Unix-like operating systems on x86-64."
  },
  {
    "id": "x86-64-ms",
    "name": "x86-64 Microsoft",
    "arch": "x86-64",
    "os": "Windows",
    "intArgRegs": ["rcx", "rdx", "r8", "r9"],
    "floatArgRegs": ["xmm0", "xmm1", "xmm2", "xmm3"],
    "intReturnRegs": ["rax"],
    "floatReturnRegs": ["xmm0"],
    "calleeSaved": ["rbx", "rbp", "rdi", "rsi", "r12", "r13", "r14", "r15", "xmm6", "xmm7", "xmm8", "xmm9", "xmm10", "xmm11", "xmm12", "xmm13", "xmm14", "xmm15"],
    "callerSaved": ["rax", "rcx", "rdx", "r8", "r9", "r10", "r11", "xmm0", "xmm1", "xmm2", "xmm3", "xmm4", "xmm5"],
    "stackPointer": "rsp",
    "framePointer": "rbp",
    "linkRegister": null,
    "stackAlignment": 16,
    "redZone": 0,
    "structPassing": "Structs of 1, 2, 4, or 8 bytes are passed in a single integer register. Larger structs are always passed via pointer (caller allocates, callee may copy). Return structs: same size rule applies; larger ones returned via hidden pointer in rcx.",
    "variadicNotes": "For variadic functions, float arguments must be duplicated in both the corresponding integer register and XMM register. For example, the 2nd argument goes in both rdx and xmm1.",
    "notes": "A 32-byte shadow space (home space) must be allocated by the caller above the return address, even if the callee takes no arguments. This space is available for the callee to spill the register parameters. No red zone exists—interrupts and signals may clobber memory below rsp."
  },
  {
    "id": "aarch64-aapcs",
    "name": "AArch64 AAPCS64",
    "arch": "AArch64",
    "os": "Linux, macOS, iOS, Android",
    "intArgRegs": ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7"],
    "floatArgRegs": ["v0", "v1", "v2", "v3", "v4", "v5", "v6", "v7"],
    "intReturnRegs": ["x0", "x1"],
    "floatReturnRegs": ["v0", "v1", "v2", "v3"],
    "calleeSaved": ["x19", "x20", "x21", "x22", "x23", "x24", "x25", "x26", "x27", "x28", "x29"],
    "callerSaved": ["x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10", "x11", "x12", "x13", "x14", "x15", "x16", "x17"],
    "stackPointer": "sp",
    "framePointer": "x29 (fp)",
    "linkRegister": "x30 (lr)",
    "stackAlignment": 16,
    "redZone": 0,
    "structPassing": "Homogeneous Floating-point Aggregates (HFAs) with up to 4 float/double members are passed in consecutive SIMD registers. Other structs up to 16 bytes are passed in one or two integer registers. Larger structs are passed by reference (caller allocates a copy).",
    "variadicNotes": "Named arguments follow normal rules. Anonymous variadic arguments are passed on the stack. The va_list is a pointer to the stack area containing the variadic arguments.",
    "notes": "x8 is the indirect result register (used when the return value is too large for registers—the caller passes the address of the return buffer in x8). x16/x17 are intra-procedure-call scratch registers (used by linker veneers and PLT stubs). x18 is the platform register (reserved on some OSes—e.g., Apple reserves it for thread-local storage)."
  },
  {
    "id": "riscv-lp64",
    "name": "RISC-V LP64/ILP32",
    "arch": "RISC-V",
    "os": "Linux, RTOS",
    "intArgRegs": ["a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7"],
    "floatArgRegs": ["fa0", "fa1", "fa2", "fa3", "fa4", "fa5", "fa6", "fa7"],
    "intReturnRegs": ["a0", "a1"],
    "floatReturnRegs": ["fa0", "fa1"],
    "calleeSaved": ["s0", "s1", "s2", "s3", "s4", "s5", "s6", "s7", "s8", "s9", "s10", "s11"],
    "callerSaved": ["t0", "t1", "t2", "t3", "t4", "t5", "t6", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7"],
    "stackPointer": "sp (x2)",
    "framePointer": "s0/fp (x8)",
    "linkRegister": "ra (x1)",
    "stackAlignment": 16,
    "redZone": 0,
    "structPassing": "Scalars up to XLEN bits in integer registers. Structs up to 2×XLEN bits are passed in one or two registers. Float/double fields in structs may be passed in FP registers if the struct has at most two fields and at least one is floating-point (hardware float ABI only). Larger structs are passed by reference.",
    "variadicNotes": "Named arguments follow normal rules. Variadic arguments are always passed in integer registers or on the stack, never in floating-point registers (even if the hardware float ABI is in use).",
    "notes": "The calling convention varies by float ABI: LP64 (soft-float—no FP registers used), LP64F (single-precision in FP regs), LP64D (double-precision in FP regs). a7 doubles as the syscall number register for ecall. The gp (x3) register holds the global pointer for linker relaxation; tp (x4) holds the thread pointer."
  },
  {
    "id": "i386-cdecl",
    "name": "i386 cdecl",
    "arch": "i386",
    "os": "Linux, Windows, BSD",
    "intArgRegs": [],
    "floatArgRegs": [],
    "intReturnRegs": ["eax", "edx"],
    "floatReturnRegs": ["st0"],
    "calleeSaved": ["ebx", "esi", "edi", "ebp"],
    "callerSaved": ["eax", "ecx", "edx"],
    "stackPointer": "esp",
    "framePointer": "ebp",
    "linkRegister": null,
    "stackAlignment": 16,
    "redZone": 0,
    "structPassing": "All arguments are passed on the stack, pushed right-to-left. The caller is responsible for cleaning up the stack after the call. Structs are copied onto the stack. Return: small structs (≤8 bytes on some compilers) in eax/edx; larger structs via hidden pointer.",
    "variadicNotes": "All arguments are on the stack, so variadic functions work naturally—va_start simply computes the address of the first variadic argument from the stack pointer and the known fixed parameters.",
    "notes": "The oldest and simplest x86 calling convention. All arguments are passed on the stack (no register arguments in the base cdecl convention). 64-bit values (long long) are passed as two 32-bit values on the stack. Floating-point arguments are pushed onto the stack as 64-bit doubles. The x87 FPU stack (st0) is used for float returns."
  }
]
